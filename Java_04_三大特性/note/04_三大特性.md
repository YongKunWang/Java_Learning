# Java_04_三大特性

> 封装
>
> 继承
>
> 多态

- [Java_04_三大特性](#Java_04_三大特性)
  * [继承的出现](#继承的出现)
  * [继承](#继承)
    + [子类中变量的特点](#子类中变量的特点)
      - [变量](#变量)
      - [函数](#函数)
      - [构造函数](#构造函数)
  * [final 关键字](#final 关键字)

## 继承的出现

```java
class Student{
    String name;
    int age;
    public void studty(){
        Sysyem.out.println("正在学习...");
    }
}

class Worker{
    String name;
    int age;
    public void worker(){
        Sysyem.out.println("正在工作...");
    }
}
```

从上述两个类的定义中，我们可以看到：

- 两个类具有相同的属性，方法不同

我们将这两个类中共同的部分进行抽象，将共同部分的属性和方法提取出来，单独进行描述。

```java
class Person {
    String name;
    int age;
}
class Student extends Person{
    public void studty(){
        Sysyem.out.println("正在学习...");
    }
}

class Worker extends Person{
    public void worker(){
        Sysyem.out.println("正在工作...");
    }
}
```

从上述代码中，我们可以看到继承的优点：

- 提高了代码的复用性
- 让类和类之间产生了联系，继承是多态的前提
- 类和类之间存在所属关系

## 继承

**Java只支持单继承，不支持多继承**

- 当多个父类具有相同的功能函数时，会带来安全隐患
- Java改良了多继承，称之为多实现
- Java支持多层继承，也就是一个继承体系
  - 我们在查看继承体系的时候，首先看体系中父类的描述部分，因为这是所有子类的共性内容
  - 通过了解其共性体系，就可以知道体系的基本功能

```java
/*多继承*/
class A{
    void show(){
        sout("a");
    }
}

class B{
    void show(){
        sout("b");
    }
}

class C extends A,B{
    C c = new C();
    c.show(); /*无法确认是a还是b*/
}
```

### 子类中变量的特点

类中的成员有： 变量 函数 构造函数

#### 变量

```java
class Fu{
    int num = 4;
}
class Zi extends Fu {
    int num = 5;
    void show(){
        System.out.println(super.num);
        System.out.println(this.num);
    }
}
```

上述代码表明：当子类和父类含有相同的成员变量时：

- 访问子类成员变量用`this`
- 访问父类成员变量使用`super`

#### 函数

```java
class Fu{
    int num = 4;
    void show(){
        sout(num);
    }
}

class Zi extends Fu{
    int num = 5;
    void show(){
        sout(this.num);
    }
}

public static void main(String[] args){
    Zi zi = new Zi();
    zi.show(); /*5*/
}
```

上述代码表明：当子类和父类出现一样的成员函数时：

- 会运行子类对象的内容
- 就相当于父类被覆盖一样

当子类继承父类时，就沿用了父类的功能到子类中，当时子类功能和父类功能是不一样的。这时，我们没有必要重新定义新功能，可以使用覆盖技术，保留父类的功能定义，并且重写其内容。

```java
class Fu{
    int num = 4;
    void show(){
        sout(num);
    }
}

class Zi extends Fu{
    int num = 5;
    void show(){
        super.show();
        sout(this.num);
    }
}

public static void main(String[] args){
    Zi zi = new Zi();
    zi.show(); /*5*/
}
```

以上代码需要注意两点：

- 子类覆盖父类时，必须保证子类权限>= 父类权限，才可以实现覆盖；否则编译失败
- 静态只能覆盖静态

#### 构造函数

```java
class Fu{
    Fu(){
        sout("Fu");
    }
}

class Zi extends Fu{
    Zi(){
        sout("Zi");
    }
}

public static void main(String[] args){
    Zi zi = new Zi(); /*Fu Zi*/
}
```

在进行子类对象初始化时，父类的构造函数也会运行，并且先于子类构造函数运行。

- 子类构造函数默认第一行有一条隐式语句 `super()`
- `super()`：会访问父类中空参数的构造函数，而且子类中所有的构造函数默认第一行都是`super()`。

为什么子类一定要访问父类的构造函数：

- 继承体系中，子类可以直接获父类中相关功能和属性，所有在实例化子类对象时，首先需要查看父类如何对这些数据进行初始化的
- 如果要访问父类中指定的构造函数，可以通过手动定义`super()`语句来进行指定

```java
class Person
{
    private String name;
    Person(String name){
        this.name = name;
    }
    void show();
}

class Student extends Person{
    Student(String name){
        super(name);
    }
    void method(){
        super.show();
    }
}
```

上述代码可以很好地解释子类的实例化过程：

- 子类中的所有构造函数默认会访问父类中空的构造函数`super()`
  - 子类构造函数中得第一行默认会有隐式语句`super()`
- 当父类中没有空的构造函数，或者子类想要指定特定的父类的构造函数。可以使用`super()`
- 子类的构造函数也可以在第一行使用`this`关键字手动指定本类的构造函数
- 子类中至少会有一个构造函数会来访问父类中的构造函数

## final 关键字

可以修饰：类 属性 方法

- 被`final `修饰的类不可以被继承
- 被`final `修饰的方法不可以被重写
- 被`final `修饰的变量是一个常量，只能赋值一次，既可以修饰成员变量，又可以修饰局部变量
  - 类似于C语言中的宏定义
  - `public static final PI = 3.14;`
- 继承打破了封装性